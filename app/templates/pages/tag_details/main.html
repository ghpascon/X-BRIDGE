{% extends "base.html" %} {% block content %}

<div class="container mx-auto p-6">
  <!-- Tags Table Widget -->
  <div class="bg-white rounded-lg shadow border p-4" x-data="tagDetailsTable()">
    <div class="justify-between flex items-center mb-4">
      <h4 class="text-lg font-semibold">
        Tags (<span x-text="tags.length"></span>)
      </h4>
      <a
        href="{{ url_for('index') }}"
        class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded text-sm"
      >
        Back
      </a>
    </div>

    <div class="border rounded overflow-hidden" style="height: 70vh">
      <div class="overflow-auto" style="height: 100%">
        <table x-show="headers.length > 0" class="w-full border-collapse">
          <thead class="bg-gray-50 sticky top-0">
            <tr>
              <template x-for="header in headers" :key="header">
                <th
                  class="px-4 py-3 text-center whitespace-nowrap border-b-2 border-gray-200 font-mono text-sm font-semibold text-gray-900"
                  x-text="header.replace(/_/g, ' ').toUpperCase()"
                ></th>
              </template>
            </tr>
          </thead>
          <tbody>
            <template x-for="tag in tags" :key="tag.epc || Math.random()">
              <tr class="border-b border-gray-200 hover:bg-gray-50">
                <template x-for="header in headers" :key="header">
                  <td
                    class="px-4 py-3 font-mono text-sm whitespace-nowrap text-gray-900"
                    :title="tag[header]"
                    x-text="tag[header] !== null && tag[header] !== undefined ? tag[header] : '-'"
                  ></td>
                </template>
              </tr>
            </template>
          </tbody>
        </table>

        <div x-show="tags.length === 0" class="p-8 text-center text-gray-400">
          No tags found
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  function tagDetailsTable() {
    return {
      tags: [],
      headers: [],

      async init() {
        await this.loadTags();
        setInterval(() => this.loadTags(), 1000);
      },

      async loadTags() {
        try {
          const response = await fetch("{{ url_for('get_tags') }}");
          if (response.ok) {
            const data = await response.json();
            this.tags = Array.isArray(data) ? data : data.tags || [];

            // Sort by timestamp if available (descending - newest first)
            if (this.tags.length > 0 && this.tags[0].timestamp) {
              this.tags.sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
              });
            }

            // Extract headers from first tag
            if (this.tags.length > 0 && this.headers.length === 0) {
              this.headers = Object.keys(this.tags[0]);
            }
          }
        } catch (error) {
          console.error("Error loading tags:", error);
        }
      },
    };
  }
</script>

{% endblock %}
